<!DOCTYPE html>
<html>
	<body onload="webGLStart();" style="width:100%; height:100%;">
		<center><canvas id="canvas" style="border: none;" width="1024px" height="768px"></canvas><br>
		<input type="radio" name="mode" value="0" checked> No AO<br>
		<input type="radio" name="mode" value="1" > SSAO<br>
		<input type="radio" name="mode" value="2" > SSDO<br>
		<input type="radio" name="mode" value="3" > SSDO+SSAO<br>
		<input type="radio" name="mode" value="4" > SSDO map<br>
		<input type="radio" name="mode" value="5" > SSAO map<br>
		Sky: <input class="jscolor" id="skyColor" value="7EC0EE"><br></center>
		<script src="jscolor.min.js"></script>
		<script type="text/javascript" src="gltools.js"></script>
		<script type="text/javascript" src="gl.js"></script>
		<script id="blurY-fs" type="x-shader/x-fragment">
			precision highp float;
			precision highp sampler2D;
			uniform sampler2D texture;
			varying vec2 texmap;

			vec4 blur(vec2 pos, vec2 v) {
				const float radius = 20.0;
				vec3 texel_radius = vec3(v.xy, radius);
				float INV_SQRT_2PI_X3 = 1.1968268412042980338198381798031;
				float exp_value = -4.5 / radius / radius;
				float sqrt_value = INV_SQRT_2PI_X3 / radius;
				float sum = 0.0;
				vec4 value = vec4(0.0,0.0,0.0,0.0);
				for(float x = 1.0; x<=radius; x+=1.0){
					float currentScale = exp(exp_value * x * x);
					sum += currentScale;
					vec2 dudv = texel_radius.xy * x;
					value +=
					    currentScale * (texture2D(texture, pos - dudv) + texture2D(texture, pos + dudv));
				}
				float correction = 1.0 / sqrt_value - 2.0 * sum;
				value += texture2D(texture, pos) * correction;
				return value * sqrt_value;
			}

			void main(void) {
				gl_FragColor = blur(texmap,vec2(0.0,0.001));
			}
		</script>
		<script id="blurY-vs" type="x-shader/x-vertex">
			attribute vec2 aVertexPosition;
			attribute vec2 aVertexTexmap;
			varying vec2 texmap;

			void main(void) {
				texmap=aVertexTexmap;
				gl_Position = vec4(aVertexPosition, 0.0, 1.0);
			}
		</script>
		<script id="blurX-fs" type="x-shader/x-fragment">
			precision highp float;
			precision highp sampler2D;
			uniform sampler2D texture;
			varying vec2 texmap;

			vec4 blur(vec2 pos, vec2 v) {
				const float radius = 20.0;
				vec3 texel_radius = vec3(v.xy, radius);
				float INV_SQRT_2PI_X3 = 1.1968268412042980338198381798031;
				float exp_value = -4.5 / radius / radius;
				float sqrt_value = INV_SQRT_2PI_X3 / radius;
				float sum = 0.0;
				vec4 value = vec4(0.0,0.0,0.0,0.0);
				for(float x = 1.0; x<=radius; x+=1.0){
					float currentScale = exp(exp_value * x * x);
					sum += currentScale;
					vec2 dudv = texel_radius.xy * x;
					value +=
					    currentScale * (texture2D(texture, pos - dudv) + texture2D(texture, pos + dudv));
				}
				float correction = 1.0 / sqrt_value - 2.0 * sum;
				value += texture2D(texture, pos) * correction;
				return value * sqrt_value;
			}

			void main(void) {
				gl_FragColor = blur(texmap,vec2(0.001,0.0));
			}
		</script>
		<script id="blurX-vs" type="x-shader/x-vertex">
			attribute vec2 aVertexPosition;
			attribute vec2 aVertexTexmap;
			varying vec2 texmap;

			void main(void) {
				texmap=aVertexTexmap;
				gl_Position = vec4(aVertexPosition, 0.0, 1.0);
			}
		</script>
		<script id="shader2d-fs" type="x-shader/x-fragment">
			precision highp float;
			precision highp sampler2D;
			uniform sampler2D colorTexture;
			uniform sampler2D positionTexture;
			uniform sampler2D normalTexture;
			uniform sampler2D ssdoTexture;
			uniform int mode;
			varying vec2 texmap;

			float gamma = 2.2;
			vec4 gammaCorrect(in vec4 v){
				return vec4(pow(v.rgb,vec3(1.0/gamma)), v.a);
			}
			vec4 textureCorrect(in vec4 v){
				return vec4(pow(v.rgb,vec3(gamma)), v.a);
			}

			const vec4 sunColor = vec4(256.0/255.0,212.0/255.0,64.0/255.0,1.0);
			void main(void) {
				vec4 color = textureCorrect(texture2D(colorTexture, texmap));
				vec3 position = texture2D(positionTexture, texmap).xyz;
				vec3 normal = texture2D(normalTexture, texmap).xyz;
				vec4 ssdo = textureCorrect(texture2D(ssdoTexture, texmap));

				vec3 L = normalize(vec3(0.0,4.0,-3.0)-position);
				vec3 E = normalize(position);

				float shininess=64.0;
				float specIntensity = 0.0;//pow(max(dot(normal,normalize(L - E)),0.0),shininess/4.0);
				specIntensity = clamp(specIntensity, 0.0, 1.0);
				float lightIntensity = dot(normal, L)*1.7;
				lightIntensity = clamp(lightIntensity, 0.0, 1.0);
				if(dot(normal, L)<=0.0){
					specIntensity=0.0;
					lightIntensity=0.0;
				}
				float ambientIntensity = 0.6;

				if(mode==2 || mode==3)
					color *= ssdo; //add SSDO
				color *= (lightIntensity*sunColor+ambientIntensity*vec4(1.0)); //diffuse and ambient
				color += vec4(1.0)*specIntensity; //spectacular
				if(mode==1 || mode==3)
					color *= ssdo.a; //add SSAO

				if(mode==4)
					color = ssdo; //SSDO map mode
				if(mode==5)
					color = vec4(ssdo.a); //SSAO map mode

				gl_FragColor = gammaCorrect(color);
				gl_FragColor.a=1.0;
			}
		</script>
		<script id="shader2d-vs" type="x-shader/x-vertex">
			attribute vec2 aVertexPosition;
			attribute vec2 aVertexTexmap;
			varying vec2 texmap;

			void main(void) {
				texmap=aVertexTexmap;
				gl_Position = vec4(aVertexPosition, 0.0, 1.0);
			}
		</script>
		<script id="ssdo-fs" type="x-shader/x-fragment">
			precision highp float;
			precision highp sampler2D;
			uniform sampler2D colorTexture;
			uniform sampler2D positionTexture;
			uniform sampler2D normalTexture;
			uniform mat4 projectionMatrix;
			uniform vec3 skyColor;
			varying vec2 texmap;

			float gamma = 2.2;
			vec4 gammaCorrect(in vec4 v){
				return vec4(pow(v.rgb,vec3(1.0/gamma)), v.a);
			}
			vec4 textureCorrect(in vec4 v){
				return vec4(pow(v.rgb,vec3(gamma)), v.a);
			}

			float rand(in vec2 co) {
				return fract(sin(dot(normalize(co.xy), vec2(12.9898, 78.233))) * 43758.5453);
			}
			const int samples = 16;
			vec3 rand3(vec3 co, int i){
				co/=10000.0;
				float ci = float(i)/float(samples);
				return vec3(
					rand(vec2(
						rand(co.xy),
						rand(vec2(co.z,ci)))
					),
					rand(vec2(
						rand(co.xz),
						rand(vec2(co.y,ci)))
					),
					rand(vec2(
						rand(vec2(co.x,ci)),
						rand(co.yz))
					));
			}
			void main(void) {
				vec4 color = textureCorrect(texture2D(colorTexture, texmap));
				vec3 position = texture2D(positionTexture, texmap).xyz;
				vec3 normal = texture2D(normalTexture, texmap).xyz;

				vec4 ssdo = vec4(0.0);
				vec4 ssdo_amb = vec4(0.0);
				float ssao = 0.0;
				int count = 0;
				const float radius = 1.0;
				const float max_distance = 2.0;
				vec4 sky = vec4(skyColor,1.0);
				for(int i=0;i<samples;i++){
					vec3 occDir = normalize(rand3(position,i) * 2.0 - 1.0);
					if(dot(normal,occDir)<=0.0) continue;
					vec3 occDiff = occDir * radius * float(i+1) / float(samples);
					vec3 occ = occDiff + position;
					vec4 occ2screen = projectionMatrix * vec4(occ, 1.0);
					occ2screen /= occ2screen.w;
					vec2 occTexCoord = clamp(occ2screen.xy*0.5+0.5,0.0,1.0);
					vec3 occPos = texture2D(positionTexture, occTexCoord).xyz;
					float occDepth = occPos.z;
					vec3 occNormal = texture2D(normalTexture, occTexCoord).xyz;
					vec4 occColor = textureCorrect(texture2D(colorTexture, occTexCoord));

					float distance =  abs(occDepth - position.z) / max_distance;
					float invisibility = ((occDepth >= occ.z) ? 1.0 : 0.0) * smoothstep(1.0, 0.0, distance);
					float geometryFactor = max(0.0,dot(occDir, normal)*dot(-occDir,occNormal));
					if(occTexCoord.x<0.0 || occTexCoord.x > 1.0 || occTexCoord.y < 0.0 || occTexCoord.y > 1.0)
						invisibility = 0.0;

					ssdo += mix(sky, occColor * geometryFactor, invisibility);
					ssdo_amb += occColor * geometryFactor;
					ssao += invisibility;

					count++;
				}
				ssdo = max(vec4(0.0),ssdo/max(float(count),1.0));
				ssdo_amb = max(vec4(0.0),ssdo_amb/max(float(count),1.0));
				ssao = 1.0-ssao/max(float(count),1.0);
				gl_FragColor=gammaCorrect(ssdo);
				gl_FragColor.a=pow(ssao,0.5);
			}
		</script>
		<script id="ssdo-vs" type="x-shader/x-vertex">
			attribute vec2 aVertexPosition;
			attribute vec2 aVertexTexmap;
			varying vec2 texmap;

			void main(void) {
				texmap=aVertexTexmap;
				gl_Position = vec4(aVertexPosition, 0.0, 1.0);
			}
		</script>
		<script id="shader3d-fs" type="x-shader/x-fragment">
			#extension GL_EXT_draw_buffers : require
			precision highp float;
			precision highp sampler2D;
			varying vec2 texmap;
			varying vec3 position;
			varying vec3 normal;
			varying vec3 normal2;

			void main(void) {
				if(normal2.z>0.5)
					gl_FragData[0] = vec4(1.0);
				else if(normal2.z>-0.5)
					gl_FragData[0] = vec4(0.0,1.0,0.0,1.0);
				else
					gl_FragData[0] = vec4(1.0, 0.0, 0.0, 1.0);
				gl_FragData[1]=vec4(position,1.0);
				gl_FragData[2]=vec4(normal,1.0);
			}
		</script>
		<script id="shader3d-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec2 aVertexTexmap;
			attribute vec3 aVertexTangent;
			attribute vec3 aVertexBinormal;
			varying vec2 texmap;
			varying vec3 position;
			varying vec3 normal;
			varying vec3 normal2;
			uniform mat4 uMVMatrix;
			uniform mat4 uNMVMatrix;
			uniform mat4 uPMatrix;

			mat3 transpose(in mat3 inMatrix) {
				vec3 i0 = inMatrix[0];
				vec3 i1 = inMatrix[1];
				vec3 i2 = inMatrix[2];

				mat3 outMatrix = mat3(
							 vec3(i0.x, i1.x, i2.x),
							 vec3(i0.y, i1.y, i2.y),
							 vec3(i0.z, i1.z, i2.z)
							 );

				return outMatrix;
			}
			void main(void) {
				texmap = aVertexTexmap;
				normal2 = aVertexNormal;
				vec3 norm=normalize((uNMVMatrix* vec4(aVertexNormal, 1.0)).xyz);
				// vec3 tangent=normalize((uNMVMatrix* vec4(aVertexTangent, 1.0)).xyz);
				// vec3 binorm=normalize((uNMVMatrix* vec4(aVertexBinormal, 1.0)).xyz);
				// mat3 TBN = transpose(mat3(
				// 	tangent,
				// 	binorm,
				// 	norm
				// ));
				vec4 position4 = uMVMatrix * vec4(aVertexPosition, 1.0);
				position = position4.xyz;
				normal = norm;
				gl_Position = uPMatrix * position4;
			}
		</script>
		<script type="text/javascript">
			"use strict";
			function cubeV(size = 1.0){
					var buffer = [
						1.0, -1.0,  -1.0,
					-1.0, -1.0,  -1.0,
					-1.0,  1.0,  -1.0,

					1.0, 1.0,  -1.0,
					1.0, -1.0,  -1.0,
					-1.0,  1.0,  -1.0,


					-1.0, -1.0,  1.0,
					1.0, -1.0,  1.0,
					1.0,  1.0,  1.0,

					-1.0, 1.0,  1.0,
					-1.0, -1.0,  1.0,
					1.0,  1.0,  1.0,


					-1.0, 1.0,  -1.0,
					-1.0, -1.0,  -1.0,
					-1.0,  -1.0,  1.0,

					-1.0, 1.0,  1.0,
					-1.0, 1.0,  -1.0,
					-1.0,  -1.0,  1.0,


					1.0, -1.0,  -1.0,
					1.0, 1.0,  -1.0,
					1.0,  1.0,  1.0,

					1.0, -1.0,  1.0,
					1.0, -1.0,  -1.0,
					1.0,  1.0,  1.0,


					1.0,  1.0, -1.0,
					-1.0,  1.0, -1.0,
					-1.0, 1.0,  1.0,

					1.0, 1.0,  1.0,
					1.0, 1.0, -1.0,
					-1.0, 1.0,  1.0,


					-1.0, -1.0,  -1.0,
					1.0, -1.0,  -1.0,
					1.0, -1.0,  1.0,

					-1.0, -1.0,  1.0,
					-1.0, -1.0,  -1.0,
					 1.0, -1.0,  1.0];
				for(var i in buffer)
					buffer[i]*=size;
				return buffer;
			}
			function cubeN(){
				return [
				0.0, 0.0, -1.0,
				0.0, 0.0, -1.0,
				0.0, 0.0, -1.0,

				0.0, 0.0, -1.0,
				0.0, 0.0, -1.0,
				0.0, 0.0, -1.0,


				0.0, 0.0,  1.0,
				0.0, 0.0,  1.0,
				0.0, 0.0,  1.0,

				0.0, 0.0,  1.0,
				0.0, 0.0,  1.0,
				0.0, 0.0,  1.0,


				-1.0, 0.0,  0.0,
				-1.0, 0.0,  0.0,
				-1.0, 0.0,  0.0,

				-1.0, 0.0,  0.0,
				-1.0, 0.0,  0.0,
				-1.0, 0.0,  0.0,


				1.0, 0.0,  0.0,
				1.0, 0.0,  0.0,
				1.0, 0.0,  0.0,

				1.0, 0.0,  0.0,
				1.0, 0.0,  0.0,
				1.0, 0.0,  0.0,


				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,

				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,
				0.0, 1.0, 0.0,


				0.0, -1.0, 0.0,
				0.0, -1.0, 0.0,
				0.0, -1.0, 0.0,

				0.0, -1.0, 0.0,
				0.0, -1.0, 0.0,
				0.0, -1.0, 0.0];
			}
			function cubeT(size = 1.0){
				var buffer = [
					2.0, 0.0,
				0.0, 0.0,
				0.0,  2.0,

				2.0, 2.0,
				2.0, 0.0,
				0.0,  2.0,


				0.0, 0.0,
				2.0, 0.0,
				2.0,  2.0,

				0.0, 2.0,
				0.0, 0.0,
				2.0,  2.0,


				2.0,  0.0,
				0.0,  0.0,
				0.0,  2.0,

				2.0,  2.0,
				2.0,  0.0,
				0.0,  2.0,


				0.0,  0.0,
				2.0,  0.0,
				2.0,  2.0,

				0.0,  2.0,
				0.0,  0.0,
				2.0,  2.0,


				2.0,  0.0,
				0.0,  0.0,
				0.0,   2.0,

				2.0,   2.0,
				2.0,  0.0,
				0.0,  2.0,


				0.0,   0.0,
				2.0,   0.0,
				2.0,  2.0,

				0.0,   2.0,
				0.0,   0.0,
				2.0,   2.0];
				for(var i in buffer)
 					buffer[i]*=size/2.0;
 				return buffer;
			}
			function initBuffers() {
				var vertices = cubeV().concat([
					2.0,  0.0, -2.0,
					-2.0,  0.0, -2.0,
					-2.0, 0.0,  2.0,

					2.0, 0.0,  2.0,
					2.0, 0.0, -2.0,
					-2.0, 0.0,  2.0,


					-1.0,  1.0, 1.0,
					1.0,  1.0, 1.0,
					-1.0, 0.0,  2.0,

					1.0, 1.0, 1.0,
					1.0, 0.0, 2.0,
					-1.0, 0.0, 2.0,
				])
				var v2 = cubeV(0.1);
				for(var i=0; i<v2.length; i+=3){
					v2[i+1]+=0.5;
					v2[i+2]+=1.15;
				}
				vertices = vertices.concat(v2);
				for(var i=0; i<vertices.length; i+=3){
					vertices[i+2]-=1.0;
				}
				renderer3d.addBuffer(vertices,3,shader3d.aVertexPosition);

				var normals = cubeN().concat([
					0.0, 1.0, 0.0,
					0.0, 1.0, 0.0,
					0.0, 1.0, 0.0,

					0.0, 1.0, 0.0,
					0.0, 1.0, 0.0,
					0.0, 1.0, 0.0,


					0.0, -1.0, -1.0,
					0.0, -1.0, -1.0,
					0.0, -1.0, -1.0,

					0.0, -1.0, -1.0,
					0.0, -1.0, -1.0,
					0.0, -1.0, -1.0,
				]).concat(cubeN());
				renderer3d.addBuffer(normals,3,shader3d.aVertexNormal);

				var texmap = cubeT().concat([
					2.0,  0.0,
					0.0,  0.0,
					0.0,   2.0,

					2.0,   2.0,
					2.0,  0.0,
					0.0,  2.0,


					0.0,  0.0,
					2.0,  0.0,
					0.0,   2.0,

					2.0,  0.0,
					2.0,   2.0,
					0.0,  2.0,
				]).concat(cubeT());
				renderer3d.addBuffer(texmap,2,shader3d.aVertexTexmap);

				var tangents = [];
				var binormals = [];
				for ( var i=0; i<vertices.length; i+=9){
					var v00 = vertices[i+0];
					var v01 = vertices[i+1];
					var v02 = vertices[i+2];
					var v10 = vertices[i+3];
					var v11 = vertices[i+4];
					var v12 = vertices[i+5];
					var v20 = vertices[i+6];
					var v21 = vertices[i+7];
					var v22 = vertices[i+8];

					// Shortcuts for UVs
					var uv00 = texmap[i/3*2+0];
					var uv01 = texmap[i/3*2+1];
					var uv10 = texmap[i/3*2+2];
					var uv11 = texmap[i/3*2+3];
					var uv20 = texmap[i/3*2+4];
					var uv21 = texmap[i/3*2+5];

					// Edges of the triangle : postion delta
					var deltaPos10 = v10-v00;
					var deltaPos11 = v11-v01;
					var deltaPos12 = v12-v02;
					var deltaPos20 = v20-v00;
					var deltaPos21 = v21-v01;
					var deltaPos22 = v22-v02;

					// UV delta
					var deltaUV10 = uv10-uv00;
					var deltaUV11 = uv11-uv01;
					var deltaUV20 = uv20-uv00;
					var deltaUV21 = uv21-uv01;
					var r = 1.0 / (deltaUV10 * deltaUV21 - deltaUV11 * deltaUV20);
					var tangent0 = (deltaPos10 * deltaUV21   - deltaPos20 * deltaUV11)*r;
					var tangent1 = (deltaPos11 * deltaUV21   - deltaPos21 * deltaUV11)*r;
					var tangent2 = (deltaPos12 * deltaUV21   - deltaPos22 * deltaUV11)*r;
					tangents.push(tangent0);
					tangents.push(tangent1);
					tangents.push(tangent2);
					tangents.push(tangent0);
					tangents.push(tangent1);
					tangents.push(tangent2);
					tangents.push(tangent0);
					tangents.push(tangent1);
					tangents.push(tangent2);
					var binormal0 = (deltaPos20 * deltaUV10   - deltaPos10 * deltaUV20)*r;
					var binormal1 = (deltaPos21 * deltaUV10   - deltaPos11 * deltaUV20)*r;
					var binormal2 = (deltaPos22 * deltaUV10   - deltaPos12 * deltaUV20)*r;
					binormals.push(binormal0);
					binormals.push(binormal1);
					binormals.push(binormal2);
					binormals.push(binormal0);
					binormals.push(binormal1);
					binormals.push(binormal2);
					binormals.push(binormal0);
					binormals.push(binormal1);
					binormals.push(binormal2);
				}
				renderer3d.addBuffer(tangents,3,shader3d.aVertexTangent);
				renderer3d.addBuffer(binormals,3,shader3d.aVertexBinormal);
			}

			var gl;
			var renderer3d;
			var shader3d;
			var fbo3d;
			var texColor3d;
			var texPos3d;
			var texNorm3d;
			var bufDepth3d;
			var ssdoFilter;
			var blurXFilter;
			var blurYFilter;
			var screenFilter;
			function tick(){
				requestAnimFrame(tick);
				fbo3d.bind();
				shader3d.bind();
				renderer3d.draw();
				fbo3d.unbind();
				ssdoFilter.draw();
				blurXFilter.draw();
				blurYFilter.draw();
				screenFilter.draw();
			}

			var angleX=0.0;
			var angleY=0.0;
			var radios;
			var skyColor;
			function webGLStart() {
				radios=document.getElementsByName('mode');
				skyColor=document.getElementById('skyColor');
				var canvas = document.getElementById("canvas");
				canvas.onmousedown = handleMouseDown;
				document.onmouseup = handleMouseUp;
				document.onmousemove = handleMouseMove;
				canvas.ontouchstart = function(e){
					if(e.preventDefault)
						e.preventDefault();
					handleMouseDown(e.changedTouches[0]);
				};
				canvas.ontouchend = function(e){
					if(e.preventDefault)
						e.preventDefault();
					handleMouseUp(e.changedTouches[0]);
				};
				canvas.ontouchmove = function(e){
					if(e.preventDefault)
						e.preventDefault();
					handleMouseMove(e.changedTouches[0]);
				};
				gl = initGL(canvas);
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.enable(gl.CULL_FACE);
				shader3d = new ShaderProgram("shader3d",gl, function(shaderProgram){
					var pMatrix = mat4.create();
					mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
					gl.uniformMatrix4fv(shaderProgram.uPMatrix, false, pMatrix);
					var mvMatrix = mat4.create();
					mat4.identity(mvMatrix);
					mat4.translate(mvMatrix, [0.0,  0.0,-3.0]);
					mat4.rotateX(mvMatrix, -1.57079632679+angleY);
					mat4.rotateZ(mvMatrix, angleX+3.14);
					gl.uniformMatrix4fv(shaderProgram.uMVMatrix, false, mvMatrix);
					var nmvMatrix=mvMatrix;
					mat4.inverse(nmvMatrix);
					mat4.transpose(nmvMatrix);
					gl.uniformMatrix4fv(shaderProgram.uNMVMatrix, false, nmvMatrix);
				});
				shader3d.addAttribute("aVertexPosition");
				shader3d.addAttribute("aVertexNormal");
				shader3d.addAttribute("aVertexTexmap");
				shader3d.addAttribute("aVertexTangent");
				shader3d.addAttribute("aVertexBinormal");
				shader3d.addUniform("uPMatrix");
				shader3d.addUniform("uMVMatrix");
				shader3d.addUniform("uNMVMatrix");

				renderer3d = new Renderer(gl);

				texColor3d = new Texture(null, gl, 0, 1024, 1024);
				texPos3d = new Texture(null, gl, TextureFlags.FLOAT, 1024, 1024);
				texNorm3d = new Texture(null, gl, TextureFlags.FLOAT, 1024, 1024);
				bufDepth3d = new RenderBuffer(gl, 1024, 1024, true);
				fbo3d = new FrameBuffer(gl);
				fbo3d.addTarget(texColor3d);
				fbo3d.addTarget(texPos3d);
				fbo3d.addTarget(texNorm3d);
				fbo3d.addRenderbuffer(bufDepth3d);

				ssdoFilter = new TextureFilter(1024,1024,{colorTexture:texColor3d,positionTexture:texPos3d,normalTexture:texNorm3d},"ssdo",gl,function(shaderProgram){
					var pMatrix = mat4.create();
					mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
					gl.uniformMatrix4fv(shaderProgram.projectionMatrix, false, pMatrix);
					gl.uniform3f(shaderProgram.skyColor, skyColor.jscolor.rgb[0]/255.0, skyColor.jscolor.rgb[1]/255.0, skyColor.jscolor.rgb[2]/255.0);
				});
				ssdoFilter.shader.addUniform("projectionMatrix");
				ssdoFilter.shader.addUniform("skyColor");

				blurXFilter = new TextureFilter(1024,1024,{texture:ssdoFilter.output},"blurX",gl);
				blurYFilter = new TextureFilter(1024,1024,{texture:blurXFilter.output},"blurY",gl);
				screenFilter = new Filter({colorTexture:texColor3d,ssdoTexture:texPos3d,normalTexture:texNorm3d,ssdoTexture:blurYFilter.output},"shader2d",gl,
				function(shaderProgram){
					for (var i = 0, length = radios.length; i < length; i++) {
						if (radios[i].checked) {
							gl.uniform1i(shaderProgram.mode, radios[i].value);
							break;
						}
					}
				});
				screenFilter.shader.addUniform("mode");

				initBuffers();

				tick();
			}
			var mouseDown = false;
			var lastMouseX = null;
			var lastMouseY = null;
			function handleMouseDown(event) {
				if(event.preventDefault)
					event.preventDefault();
				mouseDown = true;
				lastMouseX = event.clientX;
				lastMouseY = event.clientY;
				return false;
			}

			function handleMouseUp(event) {
				mouseDown = false;
			}

			function handleMouseMove(event) {
				if (!mouseDown) {
					return;
				}
				var newX = event.clientX;
				var newY = event.clientY;

				var deltaX = newX - lastMouseX;
				var deltaY = newY - lastMouseY;

				angleX+=deltaX / 573.0;
				angleY+=deltaY / 573.0;

				lastMouseX = newX
				lastMouseY = newY;
			}
		</script>

	</body>
</html>
